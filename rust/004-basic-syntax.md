# Basic Syntax/Declarations

## Basic Program Structure

```rust
// main.rs - Entry point of a binary crate
fn main() {
    println!("Hello, World!");
}
```

## Comments

```rust
// Single-line comment

/* Multi-line
   comment */

/// Documentation comment for the next item
/// Supports Markdown
pub fn documented_function() {}

//! Documentation comment for the containing item
//! Used at the top of modules or crates
```

## Variable Declarations

```rust
// Immutable by default
let x = 5;

// Mutable variable
let mut y = 10;
y += 5;

// Type annotation (usually inferred)
let z: i32 = 20;

// Constants (always immutable, must have type)
const MAX_POINTS: u32 = 100_000;

// Static variables (for global state)
static LANGUAGE: &str = "Rust";
```

## Type Inference

```rust
// Rust infers types from usage
let number = 42; // i32 by default
let float = 3.14; // f64 by default
let text = "hello"; // &str

// Explicit type when needed
let parsed: i32 = "42".parse().expect("Not a number");
```

## Statements vs Expressions

```rust
// Statement: does not return a value
let x = 5;

// Expression: returns a value (no semicolon)
let y = {
    let x = 3;
    x + 1 // Returns 4
};

// Function returning expression
fn add(a: i32, b: i32) -> i32 {
    a + b // No semicolon = return value
}
```

## Control Flow

```rust
// if expression
let number = 7;
let result = if number < 5 {
    "small"
} else if number < 10 {
    "medium"
} else {
    "large"
};

// loop (infinite)
let mut counter = 0;
let result = loop {
    counter += 1;
    if counter == 10 {
        break counter * 2; // Can return a value
    }
};

// while loop
let mut n = 3;
while n != 0 {
    println!("{}!", n);
    n -= 1;
}

// for loop
for i in 0..5 {
    println!("{}", i); // 0, 1, 2, 3, 4
}

// Iterate over collection
let arr = [10, 20, 30];
for element in arr.iter() {
    println!("{}", element);
}
```

## Match Expression

```rust
let number = 3;

match number {
    1 => println!("One"),
    2 | 3 => println!("Two or Three"),
    4..=9 => println!("Between 4 and 9"),
    _ => println!("Something else"),
}
```

## Semicolons

```rust
// Semicolon = statement (no return value)
let x = 5;

// No semicolon = expression (returns value)
fn get_value() -> i32 {
    42 // Returns 42
}

// With semicolon = returns unit type ()
fn no_return() {
    42; // Doesn't return anything
}
```

## String Formatting

```rust
let name = "Rust";
let version = 1.75;

// Basic formatting
println!("Hello, {}!", name);

// Multiple values
println!("{} version {}", name, version);

// Named arguments
println!("{lang} is version {ver}", lang = name, ver = version);

// Debug format
println!("{:?}", vec![1, 2, 3]);

// Pretty debug
println!("{:#?}", vec![1, 2, 3]);
```

> **Good to know:** Rust files use `.rs` extension. Every executable needs a `main` function. Rust is expression-oriented: most constructs return values. Use `rustfmt` to automatically format code according to standard conventions.

---

## References

- [The Rust Book - Common Programming Concepts](https://doc.rust-lang.org/book/ch03-00-common-programming-concepts.html)
- [Rust By Example - Hello World](https://doc.rust-lang.org/rust-by-example/hello.html)
- [Rust Reference - Expressions](https://doc.rust-lang.org/reference/expressions.html)


---

## Metadata

- **Generated by AI**: Claude Opus 4.5 Thinking
- **Created at**: 2026-01-16 10:00
