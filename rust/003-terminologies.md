# Terminologies

## Core Concepts

### Ownership

The core principle of Rust's memory management. Each value has a single owner, and when the owner goes out of scope, the value is dropped.

```rust
let s1 = String::from("hello");
let s2 = s1; // s1 is moved to s2, s1 is no longer valid
// println!("{}", s1); // ERROR: value borrowed after move
```

### Borrowing

Temporarily accessing data without taking ownership. Can be immutable (`&T`) or mutable (`&mut T`).

```rust
fn calculate_length(s: &String) -> usize {
    s.len() // Borrowing s without taking ownership
}
```

### Lifetime

Annotations that ensure references are always valid. The compiler uses lifetimes to prevent dangling references.

```rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() { x } else { y }
}
```

### Trait

Similar to interfaces in other languages. Defines shared behavior across types.

```rust
trait Printable {
    fn print(&self);
}
```

### Crate

A package of Rust code. Can be a binary or library.

### Module

Organizes code within a crate using `mod` keyword.

```rust
mod network {
    pub fn connect() {}
}
```

### Macro

Code that writes code. Invoked with `!` suffix.

```rust
println!("Hello, {}!", name);
vec![1, 2, 3];
```

## Memory & Types

### Stack vs Heap

- **Stack:** Fixed-size data, fast, automatic cleanup
- **Heap:** Dynamic-size data, slower, manual management (via ownership)

### Move Semantics

Transferring ownership from one variable to another. The original variable becomes invalid.

```rust
let v1 = vec![1, 2, 3];
let v2 = v1; // v1 moved to v2
```

### Copy Trait

Types that implement `Copy` are duplicated instead of moved (integers, bools, floats).

```rust
let x = 5;
let y = x; // x is copied, both x and y are valid
```

### Clone

Explicit deep copy of data.

```rust
let s1 = String::from("hello");
let s2 = s1.clone(); // Both s1 and s2 are valid
```

## Advanced Terms

### Immutable by Default

Variables are immutable unless declared with `mut`.

```rust
let x = 5; // immutable
let mut y = 10; // mutable
```

### Pattern Matching

Destructuring and matching values using `match`, `if let`, etc.

```rust
match value {
    Some(x) => println!("{}", x),
    None => println!("Nothing"),
}
```

### Zero-Cost Abstractions

High-level features that compile to efficient machine code without runtime overhead.

### Unsafe

Keyword to bypass Rust's safety guarantees when necessary (FFI, raw pointers, etc.).

```rust
unsafe {
    // Potentially dangerous operations
}
```

### FFI (Foreign Function Interface)

Calling code written in other languages (typically C).

### Cargo

Rust's build system and package manager.

### Rustc

The Rust compiler.

### rustup

Rust toolchain installer and version manager.

### Edition

Rust releases (2015, 2018, 2021, 2024) that can include breaking changes while maintaining compatibility.

> **Good to know:** Understanding ownership, borrowing, and lifetimes is crucial to mastering Rust. These concepts are the foundation of Rust's memory safety guarantees and are enforced at compile time, resulting in zero runtime overhead.

---

## References

- [The Rust Book - Common Programming Concepts](https://doc.rust-lang.org/book/ch03-00-common-programming-concepts.html)
- [Rust Glossary](https://doc.rust-lang.org/book/appendix-07-glossary.html)
- [Rust By Example](https://doc.rust-lang.org/rust-by-example/)


---

## Metadata

- **Generated by AI**: Claude Opus 4.5 Thinking
- **Created at**: 2026-01-16 10:00
