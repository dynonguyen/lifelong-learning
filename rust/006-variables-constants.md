# Variables & Constants

## Variables

### Immutable by Default

```rust
// Immutable variable
let x = 5;
// x = 6; // ERROR: cannot assign twice to immutable variable
```

### Mutable Variables

```rust
// Mutable variable (must use mut keyword)
let mut y = 10;
y = 15; // OK
y += 5; // OK
```

### Type Annotations

```rust
// Type is usually inferred
let inferred = 42;

// Explicit type annotation
let explicit: i32 = 42;

// Required when type cannot be inferred
let parsed: u32 = "42".parse().expect("Not a number");
```

### Shadowing

```rust
// Can shadow (redeclare) variables
let x = 5;
let x = x + 1; // x = 6
let x = x * 2; // x = 12

// Can change type when shadowing
let spaces = "   ";
let spaces = spaces.len(); // Now a number

// vs mutable (cannot change type)
let mut value = "text";
// value = value.len(); // ERROR: mismatched types
```

## Constants

### Constant Declaration

```rust
// Constants are ALWAYS immutable
// Must have type annotation
// Use SCREAMING_SNAKE_CASE by convention
const MAX_POINTS: u32 = 100_000;
const PI: f64 = 3.14159;

// Can use in any scope, including global
const TIMEOUT_SECONDS: u64 = 30;

// Can use const expressions
const HOUR_IN_SECONDS: u32 = 60 * 60;
```

### Constants vs Variables

```rust
// Constants:
// - Always immutable (no mut)
// - Type must be annotated
// - Can be declared in any scope (including global)
// - Value must be set at compile time
const MAX_SIZE: usize = 1024;

// Variables:
// - Immutable by default, can be mut
// - Type usually inferred
// - Function scope only (unless static)
// - Value computed at runtime
let buffer_size = calculate_size(); // Runtime computation
```

## Static Variables

### Static Declaration

```rust
// Static variables have 'static lifetime
static LANGUAGE: &str = "Rust";
static VERSION: f32 = 1.75;

// Mutable static requires unsafe to access
static mut COUNTER: u32 = 0;

unsafe {
    COUNTER += 1;
    println!("Counter: {}", COUNTER);
}
```

### Static vs Const

```rust
// Const: inlined at compile time (duplicated)
const CONST_VALUE: i32 = 100;

// Static: single memory location
static STATIC_VALUE: i32 = 100;

// Use const for simple values
// Use static for large data or when you need a fixed address
```

## Scope and Lifetime

```rust
fn main() {
    let outer = 10;

    {
        let inner = 20;
        println!("inner: {}", inner);
        println!("outer: {}", outer);
    } // inner dropped here

    // println!("inner: {}", inner); // ERROR: not in scope
    println!("outer: {}", outer); // OK
}
```

## Destructuring

```rust
// Tuple destructuring
let tuple = (1, 2, 3);
let (a, b, c) = tuple;

// Partial destructuring with _
let (x, _, z) = tuple;

// Array destructuring
let array = [1, 2, 3, 4, 5];
let [first, second, ..] = array;

// Struct destructuring
struct Point { x: i32, y: i32 }
let point = Point { x: 10, y: 20 };
let Point { x, y } = point;

// With different names
let Point { x: a, y: b } = point;
```

## Numeric Separators

```rust
// Use underscores for readability
let million = 1_000_000;
let binary = 0b1111_0000;
let hex = 0xFF_EC_DE_5E;
```

## Type Aliases

```rust
// Create type aliases for clarity
type Kilometers = i32;
type Meters = i32;

let distance: Kilometers = 5;
let height: Meters = 100;

// Complex type aliases
type Result<T> = std::result::Result<T, std::io::Error>;
type Point = (f64, f64);
```

> **Good to know:** Rust's default immutability encourages safer code. Use `mut` explicitly when you need to change values. Shadowing is different from mutation - it creates a new variable with the same name, allowing type changes. Constants are optimized at compile time and inlined wherever they're used.

---

## References

- [The Rust Book - Variables and Mutability](https://doc.rust-lang.org/book/ch03-01-variables-and-mutability.html)
- [Rust Reference - Constants](https://doc.rust-lang.org/reference/items/constant-items.html)
- [Rust Reference - Static Items](https://doc.rust-lang.org/reference/items/static-items.html)


---

## Metadata

- **Generated by AI**: Claude Opus 4.5 Thinking
- **Created at**: 2026-01-16 10:00
