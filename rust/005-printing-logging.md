# Printing/Logging

## Standard Output Macros

### println! - Print with Newline

```rust
// Basic printing
println!("Hello, World!");

// With variables
let name = "Rust";
println!("Hello, {}!", name);

// Multiple values
let x = 10;
let y = 20;
println!("x: {}, y: {}", x, y);

// Named arguments
println!("{name} is version {ver}", name = "Rust", ver = 1.75);

// Positional arguments
println!("{0} {1} {0}", "tic", "tac"); // tic tac tic
```

### print! - Print Without Newline

```rust
print!("Loading");
print!(".");
print!(".");
println!("Done!");
```

### eprintln! - Print to Standard Error

```rust
eprintln!("Error: File not found");
eprintln!("This goes to stderr instead of stdout");
```

## Formatting

### Display vs Debug

```rust
#[derive(Debug)]
struct Person {
    name: String,
    age: u32,
}

let person = Person {
    name: String::from("Alice"),
    age: 30,
};

// Debug format (requires #[derive(Debug)])
println!("{:?}", person);
// Person { name: "Alice", age: 30 }

// Pretty-print debug
println!("{:#?}", person);
// Person {
//     name: "Alice",
//     age: 30,
// }

// Custom Display (needs manual implementation)
use std::fmt;

impl fmt::Display for Person {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{} ({})", self.name, self.age)
    }
}

println!("{}", person); // Alice (30)
```

### Format Specifiers

```rust
let pi = 3.14159;
let count = 42;

// Decimal
println!("{}", count); // 42

// Binary
println!("{:b}", count); // 101010

// Hexadecimal
println!("{:x}", count); // 2a
println!("{:X}", count); // 2A

// Octal
println!("{:o}", count); // 52

// Float precision
println!("{:.2}", pi); // 3.14
println!("{:.4}", pi); // 3.1416

// Padding
println!("{:5}", count); // "   42"
println!("{:05}", count); // "00042"
println!("{:<5}", count); // "42   "
println!("{:>5}", count); // "   42"
println!("{:^5}", count); // " 42  "
```

## Debug Macros

### dbg! - Debug Print with Context

```rust
let x = 5;
let y = dbg!(x * 2) + 1; // Prints: [src/main.rs:2] x * 2 = 10

// Returns the value, so it can be used in expressions
let result = dbg!(10 + 20); // result = 30

// Multiple values
dbg!(x, y, x + y);
```

## Logging with the `log` Crate

### Setup

```toml
# Cargo.toml
[dependencies]
log = "0.4"
env_logger = "0.11"  # Popular logging implementation
```

### Usage

```rust
use log::{debug, error, info, trace, warn};

fn main() {
    // Initialize logger
    env_logger::init();

    trace!("Very detailed information");
    debug!("Debug information");
    info!("General information");
    warn!("Warning message");
    error!("Error occurred");
}
```

### Log Levels

```bash
# Set log level via environment variable
RUST_LOG=debug cargo run
RUST_LOG=info cargo run
RUST_LOG=error cargo run

# Filter by module
RUST_LOG=my_crate::my_module=debug cargo run
```

## Advanced Logging with `tracing`

```toml
# Cargo.toml
[dependencies]
tracing = "0.1"
tracing-subscriber = "0.3"
```

```rust
use tracing::{debug, error, info, instrument, span, warn, Level};

#[instrument]
fn process_data(input: &str) {
    info!("Processing: {}", input);
    let span = span!(Level::DEBUG, "inner_operation");
    let _enter = span.enter();
    debug!("Inner processing");
}

fn main() {
    tracing_subscriber::fmt::init();
    process_data("test");
}
```

## Formatting to String

```rust
// format! - Create String without printing
let s = format!("Hello, {}!", "World");
assert_eq!(s, "Hello, World!");

// With numbers
let formatted = format!("{:.2}", 3.14159);
assert_eq!(formatted, "3.14");
```

## Write to Other Destinations

```rust
use std::io::{self, Write};

// Write to stdout
let stdout = io::stdout();
let mut handle = stdout.lock();
writeln!(handle, "Hello, World!").unwrap();

// Write to String
let mut buffer = String::new();
use std::fmt::Write as FmtWrite;
writeln!(&mut buffer, "Line 1").unwrap();
writeln!(&mut buffer, "Line 2").unwrap();
```

> **Good to know:** The `println!` macro is great for quick debugging, but `dbg!` is often more useful because it prints the file location and returns the value. For production code, use the `log` crate (for libraries) or `tracing` (for applications) instead of `println!`. Set `RUST_LOG` environment variable to control log verbosity.

---

## References

- [Rust std::fmt](https://doc.rust-lang.org/std/fmt/)
- [The Rust Book - Printing](https://doc.rust-lang.org/book/ch02-00-guessing-game-tutorial.html#printing-values-with-println-placeholders)
- [log crate](https://docs.rs/log/)
- [tracing crate](https://docs.rs/tracing/)
- [env_logger](https://docs.rs/env_logger/)


---

## Metadata

- **Generated by AI**: Claude Opus 4.5 Thinking
- **Created at**: 2026-01-16 10:00
